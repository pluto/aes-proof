import { WitnessTester } from "circomkit";
import { circomkit } from "../common";


describe("GhashMul", () => {
  let circuit: WitnessTester<["X", "Y"], ["out"]>;

  before(async () => {
    circuit = await circomkit.WitnessTester("ghash_gmul", {
      file: "aes-gcm/ghash_gmul",
      template: "GhashMul",
    });
  });

  it("Should Compute GhashMul Correctly", async () => {

    let X = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let Y = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];

    const expected = [0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    await circuit.expectPass({ X: X, Y: Y }, { out: expected });
  });

  it("Should Compute NistGMulByte of LSB=1 Correctly", async () => {

    let X = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let Y = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];

    const expected = [0xe6, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03];
    await circuit.expectPass({ X: X, Y: Y }, { out: expected });
  });
  it("Should Compute NistGMulByte of LSB=1 Correctly", async () => {

    // x = "aae06992acbf52a3e8f4a96ec9300bd7"
    // y = "98e7247c07f0fe411c267e4384b0f600"
    // expected = "90e87315fb7d4e1b4092ec0cbfda5d7d"
    let X = [0xaa, 0xe0, 0x69, 0x92, 0xac, 0xbf, 0x52, 0xa3, 0xe8, 0xf4, 0xa9, 0x6e, 0xc9, 0x30, 0x0b, 0xd7];
    let Y = [0x98, 0xe7, 0x24, 0x7c, 0x07, 0xf0, 0xfe, 0x41, 0x1c, 0x26, 0x7e, 0x43, 0x84, 0xb0, 0xf6, 0x00];

    const expected = [0x90, 0xe8, 0x73, 0x15, 0xfb, 0x7d, 0x4e, 0x1b, 0x40, 0x92, 0xec, 0x0c, 0xbf, 0xda, 0x5d, 0x7d];
    await circuit.expectPass({ X: X, Y: Y }, { out: expected });
  });

});

describe("BlockRightShift", () => {
  let circuit: WitnessTester<["in"], ["out", "msb"]>;

  before(async () => {
    circuit = await circomkit.WitnessTester("BlockRightShift", {
      file: "aes-gcm/ghash_gmul",
      template: "BlockRightShift",
      params: [16]
    });
  });

  it("Should Compute BlockRightShift Correctly", async () => {
    let input = [0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    const expected = [0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    await circuit.expectPass({ in: input }, { out: expected, msb: 0 });
  });
  it("Should Compute BlockRightShift Correctly", async () => {
    let input = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    const expected = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    await circuit.expectPass({ in: input }, { out: expected, msb: 1 });
  });
});

describe("Mulx", () => {
  let circuit: WitnessTester<["in"], ["out"]>;

  before(async () => {
    circuit = await circomkit.WitnessTester("Mulx", {
      file: "aes-gcm/ghash_gmul",
      template: "Mulx",
      params: [16]
    });
  });
  // msb is 1 so we xor the first byte with 0xE1
  it("Should Compute Mulx Correctly", async () => {
    let input = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    const expected = [0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    await circuit.expectPass({ in: input }, { out: expected });
  });
});

describe("Z_UPDATE", () => {
  let circuit: WitnessTester<["Z", "V", "bit_val"], ["Z_new"]>;

  before(async () => {
    circuit = await circomkit.WitnessTester("XORBLOCK", {
      file: "aes-gcm/ghash_gmul",
      template: "Z_UPDATE",
      params: [16]
    });
  });
  // msb is 1 so we xor the first byte with 0xE1
  it("Should Compute block XOR Correctly", async () => {
    let inputZ = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let inputV = [0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let inputc = 0x00;
    let expected = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    await circuit.expectPass({ Z: inputZ, V: inputV, bit_val: inputc }, { Z_new: expected });
  });

  it("Should Compute block XOR Correctly", async () => {
    let inputa = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
    let inputb = [0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    let inputc = 0x01;
    const expected = [0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01];
    await circuit.expectPass({ Z: inputa, V: inputb, bit_val: inputc }, { Z_new: expected });
  });
});
